using Nuke.CoberturaConverter;
using Nuke.Common;
using Nuke.Common.Tools.DotCover;
using Nuke.Common.Tools.DotNet;
using Nuke.Common.Tools.ReportGenerator;
using Nuke.Common.Tools.WebConfigTransformRunner;
using Nuke.Common.Utilities;
using Nuke.WebDeploy;
using System.IO;
using static Nuke.CoberturaConverter.CoberturaConverterTasks;
using static Nuke.Common.IO.FileSystemTasks;
using static Nuke.Common.IO.PathConstruction;
using static Nuke.Common.Tools.DotCover.DotCoverTasks;
using static Nuke.Common.Tools.DotNet.DotNetTasks;
using static Nuke.Common.Tools.ReportGenerator.ReportGeneratorTasks;
using static Nuke.Common.Tools.WebConfigTransformRunner.WebConfigTransformRunnerTasks;
using static Nuke.WebDeploy.WebDeployTasks;
using Nuke.Common.ProjectModel;
using Nuke.Common.Tooling;
using System;
using static Nuke.Common.IO.TextTasks;
using Nuke.Common.Tools.GitVersion;
using Microsoft.Azure.Management.Fluent;
using Microsoft.Azure.Management.ResourceManager.Fluent;
using static Nuke.Common.IO.HttpTasks;
using Newtonsoft.Json.Linq;
using System.Linq;
using Nuke.Common.Utilities.Collections;
using Nuke.Common.Tools.AzureKeyVault.Attributes;
using Nuke.Common.Tools.AzureKeyVault;
using Nuke.Common.IO;

class Build : NukeBuild
{
    // Console application entry point. Also defines the default target.
    public static int Main() => Execute<Build>(x => x.Compile);

    [KeyVaultSettings(
        BaseUrlParameterName = nameof(KeyVaultBaseUrl),
        ClientIdParameterName = nameof(KeyVaultClientId),
        ClientSecretParameterName = nameof(KeyVaultClientSecret))]
    readonly KeyVaultSettings KeyVaultSettings;

    [Parameter] string KeyVaultBaseUrl;
    [Parameter] string KeyVaultClientId;
    [Parameter] string KeyVaultClientSecret;
    [KeyVault] KeyVault KeyVault;

    [GitVersion(Framework = "netcoreapp3.1")] readonly GitVersion GitVersion;

    [Parameter] readonly string PublishEnvironmentName;
    [Parameter] readonly string WebDeployUsernameSecretName;
    [Parameter] readonly string WebDeployPasswordSecretName;
    [Parameter] readonly string WebDeployPublishUrlSecretName;
    [Parameter] readonly string WebDeploySiteNameSecretName;

    [KeyVaultSecret("DanglDocu-AzureServicePrincipalClientId")] string AzureServicePrincipalClientId;
    [KeyVaultSecret("DanglDocu-AzureServicePrincipalClientSecret")] string AzureServicePrincipalClientSecret;
    [KeyVaultSecret("DanglDocu-AzureServicePrincipalTenantId")] string AzureServicePrincipalTenantId;
    [KeyVaultSecret("DanglDocu-AzureAppServiceStagingSlotName")] string AzureAppServiceStagingSlotName;
    [KeyVaultSecret("DanglDocu-AzureAppServiceName")] string AzureAppServiceName;

    [Parameter] readonly string Configuration = IsLocalBuild ? "Debug" : "Release";

    [Solution("Dangl.WebDocumentation.sln")] readonly Solution Solution;
    AbsolutePath SolutionDirectory => Solution.Directory;
    AbsolutePath OutputDirectory => SolutionDirectory / "output";
    AbsolutePath SourceDirectory => SolutionDirectory / "src";

    Target Clean => _ => _
            .Executes(() =>
            {
                GlobDirectories(SourceDirectory, "**/bin", "**/obj").ForEach(DeleteDirectory);
                EnsureCleanDirectory(OutputDirectory);
            });

    Target GenerateVersion => _ => _
        .Executes(() =>
        {
            var buildDate = DateTime.UtcNow;

            var filePath = SourceDirectory / "Dangl.WebDocumentation" / "Services" / "VersionsService.cs";

            var currentDateUtc = $"new DateTime({buildDate.Year}, {buildDate.Month}, {buildDate.Day}, {buildDate.Hour}, {buildDate.Minute}, {buildDate.Second}, DateTimeKind.Utc)";

            var content = $@"using System;

namespace Dangl.WebDocumentation.Services
{{
    // This file is automatically generated
    [System.CodeDom.Compiler.GeneratedCode(""GitVersionBuild"", """")]
    public static class VersionsService
    {{
        public static string Version => ""{GitVersion.NuGetVersionV2}"";
        public static string CommitInfo => ""{GitVersion.FullBuildMetaData}"";
        public static string CommitDate => ""{GitVersion.CommitDate}"";
        public static string CommitHash => ""{GitVersion.Sha}"";
        public static string InformationalVersion => ""{GitVersion.InformationalVersion}"";
        public static DateTime BuildDateUtc {{ get; }} = {currentDateUtc};
    }}
}}";
            WriteAllText(filePath, content);
        });

    Target Restore => _ => _
            .DependsOn(Clean)
            .DependsOn(GenerateVersion)
            .Executes(() =>
            {
                DotNetRestore();
            });

    Target Compile => _ => _
            .DependsOn(Restore)
            .Executes(() =>
            {
                DotNetBuild(x => x
                    .SetConfiguration(Configuration)
                    .EnableNoRestore());
            });

    Target Coverage => _ => _
        .DependsOn(Compile)
        .Requires(() => Configuration.EqualsOrdinalIgnoreCase("Debug")) // Required for coverage data gathering
        .Executes(async () =>
        {
            var testProjectDirectory = SolutionDirectory / "test" / "Dangl.WebDocumentation.Tests";

            DotCoverAnalyse(x => x
                .SetTargetExecutable(ToolPathResolver.GetPathExecutable("dotnet"))
                .SetTargetWorkingDirectory(testProjectDirectory)
                .SetTargetArguments($"test --no-build --test-adapter-path:. \"--logger:xunit;LogFilePath={OutputDirectory / "testresults.xml"}\"")
                .SetFilters("+:Dangl.WebDocumentation")
                .SetAttributeFilters("System.CodeDom.Compiler.GeneratedCodeAttribute")
                .SetOutputFile(OutputDirectory / "dotCover.xml")
                .SetReportType(DotCoverReportType.DetailedXml));

            //// This is the report that's pretty and visualized in Jenkins
            ReportGenerator(c => c
                .SetFramework("netcoreapp2.1")
                .SetReports(OutputDirectory / "dotCover.xml")
                .SetTargetDirectory(OutputDirectory / "CoverageReport"));

            //// This is the report in Cobertura format that integrates so nice in Jenkins
            //// dashboard and allows to extract more metrics and set build health based
            //// on coverage readings
            await DotCoverToCobertura(s => s
                    .SetInputFile(OutputDirectory / "dotCover.xml")
                    .SetOutputFile(OutputDirectory / "cobertura.xml"))
                .ConfigureAwait(false);
        });

    Target Publish => _ => _
        .DependsOn(Restore)
        .Requires(() => Configuration.EqualsOrdinalIgnoreCase("Release"))
        .Executes(() =>
        {
            DotNetPublish(s => s.SetProject(SourceDirectory / "Dangl.WebDocumentation")
                    .SetOutput(OutputDirectory)
                    .SetConfiguration(Configuration));

            WebConfigTransformRunner(p => p.SetWebConfigFilename(OutputDirectory / "web.config")
                .SetTransformFilename(OutputDirectory / $"web.{PublishEnvironmentName}.config")
                .SetOutputFilename(OutputDirectory / "web.config"));

            foreach (var configFileToDelete in GlobFiles(OutputDirectory, "web.*.config"))
            {
                File.Delete(configFileToDelete);
            }

            foreach (var configFileToDelete in GlobFiles(OutputDirectory, "appsettings.*.json"))
            {
                if (!configFileToDelete.EndsWithOrdinalIgnoreCase($"{PublishEnvironmentName}.json"))
                {
                    File.Delete(configFileToDelete);
                }
            }
        });

    Target Deploy => _ => _
        .DependsOn(Publish)
        .Requires(() => WebDeployUsernameSecretName)
        .Requires(() => WebDeployPasswordSecretName)
        .Requires(() => WebDeployPublishUrlSecretName)
        .Requires(() => WebDeploySiteNameSecretName)
        .Executes(async () =>
        {
            var webDeployUsername = await KeyVault.GetSecret(WebDeployUsernameSecretName);
            var webDeployPassword = await KeyVault.GetSecret(WebDeployPasswordSecretName);
            var webDeployPublishUrl = await KeyVault.GetSecret(WebDeployPublishUrlSecretName);
            var webDeploySiteName = await KeyVault.GetSecret(WebDeploySiteNameSecretName);

            WebDeploy(s => s.SetSourcePath(OutputDirectory)
                .SetUsername(webDeployUsername)
                .SetPassword(webDeployPassword)
                .SetEnableAppOfflineRule(true)
                .SetPublishUrl(webDeployPublishUrl.TrimEnd('/') + "/msdeploy.axd?site=" + webDeploySiteName)
                .SetSiteName(webDeploySiteName)
                .SetEnableDoNotDeleteRule(false)
                .SetWrapAppOffline(true));
        })
        .Executes(SwapStagingAndProductionSlotsInAzure);

    Target SwapStagingAndProductionSlotsInAzure => _ => _
        .Requires(() => AzureServicePrincipalClientId)
        .Requires(() => AzureServicePrincipalClientSecret)
        .Requires(() => AzureServicePrincipalTenantId)
        .Requires(() => AzureAppServiceStagingSlotName)
        .Requires(() => AzureAppServiceName)
        .Executes(async () =>
        {
            if (PublishEnvironmentName == "Production")
            {
                Logger.Log(LogLevel.Normal, "Deployed to production, initiating slot swap with staging");

                var azureCredentials = SdkContext.AzureCredentialsFactory.FromServicePrincipal(AzureServicePrincipalClientId,
                    AzureServicePrincipalClientSecret,
                    AzureServicePrincipalTenantId,
                    AzureEnvironment.AzureGlobalCloud);
                IAzure azure = Azure.Configure()
                    .WithLogLevel(Microsoft.Azure.Management.ResourceManager.Fluent.Core.HttpLoggingDelegatingHandler.Level.Basic)
                    .Authenticate(azureCredentials)
                    .WithDefaultSubscription();
                Logger.Log(LogLevel.Normal, "Getting information about the web app");
                var webApp = (await azure.AppServices.WebApps
                    .ListAsync())
                    .First(app => app.Name == AzureAppServiceName);
                Logger.Log(LogLevel.Normal, "Getting information about the staging slot");
                var slot = (await webApp.DeploymentSlots.ListAsync())
                    .First(s => s.Name == AzureAppServiceStagingSlotName);

                var statusUrl = $"https://{slot.DefaultHostName}/api/status";
                if (!(bool)JObject.Parse(await HttpDownloadStringAsync(statusUrl))["isHealthy"])
                {
                    ControlFlow.Fail("The web app in the staging slot does not report a healthy status");
                }

                Logger.Log(LogLevel.Normal, "Starting swap");
                // "production" is the default name for the main slot
                await slot.SwapAsync("production");
            }
        });
}
